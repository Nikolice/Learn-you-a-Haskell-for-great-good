# So: what's â€œHaskellâ€? ğŸ¤¨

[â€œHaskellâ€](https://en.wikipedia.org/wiki/Haskell_(programming_language)) â€“ is a purely *functional* programming language. ğŸ‘¾

In *imperative* languages â€“ you get things *done* by giving (to the Computer ğŸ¤–) a *sequence* of tasks (0ï¸âƒ£, 1ï¸âƒ£, 2ï¸âƒ£, 3ï¸âƒ£, â€¦), and then â€“ it executes them â€¦ While executing them â€“ it can change â€œstateâ€; for instance: you set a variable `a` to `5`, and then â€“ do some â€œstuffâ€, and then â€“ *reset* it (to something else). You have control flow structures (for doing some action, *several* times). 

But, in purely *functional* programming â€“ you *don't* tell (to the Computer ğŸ¤–) *what to __do__*, but (rather) *what the stuff __is__*: 
- The â€œ_factorial_â€ (of a number) â€“ **is** the product of *all* the numbers: from `1` â€“ to that number;
- The â€œ_sum_â€ (of a list of numbers) â€“ **is** the *first* number, plus â€“ the sum of all *other* numbers;
- â€¦ and â€“ so â€“ on.

You express **_that_** â€“ in the form of **functions**. You (also) can't *set* a variable to *something* â€“ and (then) *reset* it (to something else) later. If you say: Â«The `a` â€“ is `5`Â» â€“ you can't say Â«It's something *else*!Â» later, because you *have* said: Â«It â€“ was `5`Â» â€¦ What are you â€“ some kind of **_liar_**? ğŸ’”

â€¦Â So, in purely *functional* languages â€“ a *function* has *no* side-effects! âœ¨ â€¦ The *only* thing it can do â€“ is â€“ to calculate (and return) something (as a _result_) ğŸ§® â€¦ At first, â€“ this â€“ seems â€œlimitingâ€, â€“ but â€“ has some *very* nice consequences: if a function is called *twice* (with **the _same_** parameters) â€“ it's *guaranteed* â€“ to return the **same** _result_! â€¦ That's â€“ called **_â€œreferential transparencyâ€_**; and â€“ not only does it allow the **Compiler** ğŸ¤– to reason about the Program's _behavior_, â€“ but â€“ it (also) allows **you** to easily *deduce* (and â€“ even *prove*) that: Â«The **function** is _correct_!Â»; â€“ and (then) â€“ build more *complex* functions: by â€œgluingâ€ simple functions, together. ğŸ§±

â€œHaskellâ€ â€“ is **_â€œlazyâ€_** ğŸ˜´; that â€“ means that (un-less *specifically* told other-wise): â€œHaskellâ€ *won't* execute functions (and â€“ calculate things) until it's *really* forced to show you the â€œresultâ€ ğŸ’¤ â€¦ That â€“ goes well with **_â€œreferential transparencyâ€_**; and â€“ it allows *you* ğŸ“ to think of **programs** as of series of _transformations_ on *data* â€¦ It (also) allows â€œcoolâ€ things, â€“ such as *infinite* data structures â€¦ Say, you have an *immutable* list (of numbers: `xs = [1, 2, 3, 4, 5, 6, 7, 8]`), and â€“ a function (`doubleMe`, which multiplies *every* element by â€œ2â€, and then returns a *new* list):
- If we wanted to multiply our list by â€œ8â€ (in an *imperative* language), and did a `doubleMe(doubleMe(doubleMe(xs)))` â€“ it would (probably) pass (through the list) *once*, and â€“ make a *copy*, and (then) â€“ re-turn it; â€¦ then â€“ it would *pass* (through the list) for *another* two times, and â€“ re-turn the *result*. 
- In a â€œlazyâ€ language, â€“ calling `doubleMe` on a list (without forcing it, to show you the result) â€“ ends up in the program (sort of) â€œtellingâ€ you: **_Â«Yeah, yeah! â€¦ I'll do it, later!Â»_**. But once you want to *see* the result â€“ then, the *first* `doubleMe` tells (to the *second* one): **_Â«It wants the result; now!Â»_**. The second one â€“ says that to the *third* one; and the third one (reluctantly) â€“ gives back a doubled `1` (which â€“ is a `2`). The second one â€“ receives that, and gives back a `4` (to the first one)â€¦ The first one â€“ sees that, and tells (to you): **_Â«The *first* element â€“ is an `8`â€¦Â»_**. So, it (only) does *one* pass (through the list); and â€“ only when you **really** need it! â€¦ That way, when you want some-thing (from a *lazy* language) â€“ you can (just) take some *initial* data, and (efficiently) transform (and mend) it; so â€“ it resembles, what you want, at the end. 

â€œHaskellâ€ â€“ is **statically** typed. When you compile your Program, â€“ the Compiler ğŸ¤– knows: 
- Which â€œpieceâ€ (of code) is a number;
- Which â€“ is a string;
- â€¦ and â€“ so â€“ on. 

That means, that: a lot of (possible) errors â€“ are caught at *compile* time! â€¦ If you try to add (together) a â€œnumberâ€ and a â€œstringâ€ â€“ the compiler ğŸ¤– will **whine** at you! â€¦ â€œHaskellâ€ uses a type system, which has a **type inference**. That means, that: you *don't* have to *explicitly* label every piece (of code) with a type â€“ because the â€œtype systemâ€ can (intelligently) figure out *a lot* about itâ€¦ If you say: Â«`a = 5 + 4`Â» â€“ you *don't* have to tell â€œHaskellâ€ that: **_Â«`a` â€“ is a numberÂ»_**, â€“ it can figure that out (by itself). Type inference (also) allows your code to be *more* general! â€¦ If a function (you make) takes two parameters (and â€“ adds them, together), and you *don't* (explicitly) state their type â€“ the function *will* work on *any* two parameters (which â€“ act like numbers). 

â€œHaskellâ€ â€“ is **elegant** and **concise** â€¦ Because it uses a lot of â€œhigh levelâ€ concepts, â€“ â€œHaskellâ€ programs are (usually) shorter, than their *imperative* equivalents. And, shorter programs â€“ are *easier* to maintain (than *longer* ones), and â€“ have *less* â€œbugsâ€. ğŸ›

â€œHaskellâ€ â€“ was made by some **_really_** smart guys (with â€œPh. D.â€s ğŸ“). Work (on â€œHaskellâ€) â€“ began in 1987: when a committee (of researchers) got together to design a *nice* languageâ€¦ In 2003 â€“ the Â«â€œHaskellâ€ reportÂ» was published (which â€“ defines a **stable** version, of the *language*). 